<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CSScriptLibrary</name>
    </assembly>
    <members>
        <member name="T:csscript.AssemblyExecutor">
            <summary>
            Executes "public static void Main(..)" of assembly in a separate domain.
            </summary>
        </member>
        <member name="T:csscript.RemoteExecutor">
            <summary>
            Invokes static method 'Main' from the assembly.
            </summary>
        </member>
        <member name="M:csscript.RemoteExecutor.ResolveEventHandler(System.Object,System.ResolveEventArgs)">
            <summary>
            AppDomain evant handler. This handler will be called if CLR cannot resolve 
            referenced local assemblies 
            </summary>
        </member>
        <member name="T:csscript.Settings">
            <summary>
            Settings is an class that holds CS-Script application settings.
            </summary>
        </member>
        <member name="M:csscript.Settings.ExpandCleanupShellCommand">
            <summary>
            Returns value of the CleanupShellCommand (with expanding environment variables). 
            </summary>
            <returns>shell command string</returns>
        </member>
        <member name="M:csscript.Settings.ExpandUseAlternativeCompiler">
            <summary>
            Returns value of the UseAlternativeCompiler (with expanding environment variables). 
            </summary>
            <returns>Path string</returns>
        </member>
        <member name="M:csscript.Settings.ExpandUsePostProcessor">
            <summary>
            Returns value of the UsePostProcessor (with expanding environment variables). 
            </summary>
            <returns>Path string</returns>
        </member>
        <member name="M:csscript.Settings.ExpandDefaultRefAssemblies">
            <summary>
            Returns value of the DefaultRefAssemblies (with expanding environment variables). 
            </summary>
            <returns>List of assembly names</returns>
        </member>
        <member name="M:csscript.Settings.AddSearchDir(System.String)">
            <summary>
            Add search directory to the search (probing) path Settings.SearchDirs. 
            For example if Settings.SearchDirs = "c:\scripts" then after call Settings.AddSearchDir("c:\temp") Settings.SearchDirs is "c:\scripts;c:\temp"
            </summary>
            <param name="dir">Directory path.</param>
        </member>
        <member name="M:csscript.Settings.Save(System.String)">
            <summary>
            Saves CS-Script application settings to a file (.dat).
            </summary>
            <param name="fileName">File name of the .dat file</param>
        </member>
        <member name="M:csscript.Settings.Load(System.String)">
            <summary>
            Loads CS-Script application settings from a file. Default settings object is returned if it cannot be loaded from the file.
            </summary>
            <param name="fileName">File name of the XML file</param>
            <returns>Setting object deserialized from the XML file</returns>
        </member>
        <member name="M:csscript.Settings.Load(System.String,System.Boolean)">
            <summary>
            Loads CS-Script application settings from a file.
            </summary>
            <param name="fileName">File name of the XML file</param>
            <param name="createAlways">Create and return default settings object if it cannot be loaded from the file.</param>
            <returns>Setting object deserialized from the XML file</returns>
        </member>
        <member name="P:csscript.Settings.CleanupShellCommand">
            <summary>
            Command to be executed to perform custom cleanup. 
            If this value is empty automatic cleanup of all 
            temporary files will occurs after the script execution.
            This implies that the script has to be executed in the 
            separate AppDomain and some performance penalty will be incurred.
            
            Setting this value to the command for custom cleanup application 
            (e.g. csc.exe cleanTemp.cs) will force the script engine to execute 
            script in the 'current' AppDomain what will improve performance.
            </summary>
        </member>
        <member name="P:csscript.Settings.DoCleanupAfterNumberOfRuns">
            <summary>
            This value indicates frequency of the custom cleanup
            operation. It has affect only if CleanupShellCommand is not empty.
            </summary>
        </member>
        <member name="P:csscript.Settings.UseAlternativeCompiler">
            <summary>
            Location of alternative code provider assembly. If set it forces script engine to use an alternative code compiler. 
            </summary>
        </member>
        <member name="P:csscript.Settings.UsePostProcessor">
            <summary>
            Location of PostProcessor assembly. If set it forces script engine to pass comiled script through PostProcessor before the execution. 
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultApartmentState">
            <summary>
            DefaultApartmentState is an ApartmemntState, which will be used 
            at run-time if none specified in the code with COM threading model attributes.
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultArguments">
            <summary>
            Default command-line arguments. For example if "/dbg" is specified all scripts will be compiled in debug mode
            regardless if the user specified "/dbg" when a particular script is launched.
            </summary>
        </member>
        <member name="P:csscript.Settings.TargetFramework">
            <summary>
            Specifies the .NET Framework version that the application targets. This option can have the following values:
              v2.0
              v3.0
              v3.5
              v4.0
            </summary>
        </member>
        <member name="P:csscript.Settings.DefaultRefAssemblies">
            <summary>
            List of assembly names to be automatically referenced by the scripst. The items must be separated by coma or semicolon. Specifying .dll extension (e.g. System.Core.dll) is optional.
            Assembly can contain expandable environment variables.
            </summary>
        </member>
        <member name="P:csscript.Settings.SearchDirs">
            <summary>
            List of directories to be used to search (probing) for referenced assemblies and script files.
            This setting is similar to the system environment variable PATH.
            </summary>
        </member>
        <member name="P:csscript.Settings.HideAutoGeneratedFiles">
            <summary>
            The value, which indicates if auto-generated files (if any) should should be hidden in the temporary directory.
            </summary>
        </member>
        <member name="P:csscript.Settings.ReportDetailedErrorInfo">
            <summary>
            Boolean flag that indicates how much error details to be reported should error occur.
            false - Top level exception will be reported
            true - Whole exception stack will be reported
            </summary>
        </member>
        <member name="P:csscript.Settings.OptimisticConcurrencyModel">
            <summary>
            Gets or sets a value indicating whether Optimistic Concurrency model should be used when executing scripts from the host application.
            If set to <c>true</c> the script loading (not the execution) is globally thread-safe. If set to <c>false</c> the script loading is
            thread-safe only among loading operations for the same script file.
            <para>The default value is <c>true</c>.</para>
            </summary>
            <value>
            	<c>true</c> if Optimistic Concurrency model otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:csscript.Settings.HideCompilerWarnings">
            <summary>
            Boolean flag that indicates if compiler warnings should be included in script compilation output.
            false - warnings will be displayed
            true - warnings will not be displayed
            </summary>
        </member>
        <member name="P:csscript.Settings.InMemoryAsssembly">
            <summary>
            Boolean flag that indicates the script assembly is to be loaded by CLR as an in-memory byte stream instead of the file.
            This setting can be useful when you need to prevent script assembly (compiled script) from locking by CLR during the execution.
            false - script assembly will be loaded as a file. It is an equivalent of Assembly.LoadFrom(string assemblyFile).
            true - script assembly will be loaded as a file. It is an equivalent of Assembly.Load(byte[] rawAssembly)
            </summary>
        </member>
        <member name="T:csscript.Settings.HideOptions">
            <summary>
            Enum for possible hide auto-generated files scenarios
            Note: when HideAll is used it is responsibility of the pre/post script to implement actual hiding. 
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.DoNotHide">
            <summary>
            Do not hide auto-generated files.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.HideMostFiles">
            <summary>
            Hide the most of the auto-generated (cache and "imported") files.
            </summary>
        </member>
        <member name="F:csscript.Settings.HideOptions.HideAll">
            <summary>
            Hide all auto-generated files including the files generated by pre/post scripts.
            </summary>
        </member>
        <member name="T:csscript.CSExecutor">
            <summary>
            CSExecutor is an class that implements execution of *.cs files.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ParseAppArgs(System.String[])">
            <summary>
            Parses application (script engine) arguments.
            </summary>
            <param name="args">Arguments</param>
            <returns>Index of the first script argument</returns>
        </member>
        <member name="M:csscript.CSExecutor.Execute(System.String[],csscript.PrintDelegate,System.String)">
            <summary>
            The main entry point for the application.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetCustomAppConfig(System.String[])">
            <summary>
            Returns custom application config file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.VoidPrint(System.String)">
            <summary>
            Dummy 'print' to suppress displaying application messages.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.lastException">
            <summary>
            This method implements compiling and execution of the script.  
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ExecuteImpl">
            <summary>
            This method implements compiling and execution of the script.  
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Compile(System.String,System.String,System.Boolean)">
            <summary>
            Compiles C# script file into assembly.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.PathGetTempFileName">
            <summary>
            More reliable version of the Path.GetTempFileName(). 
            It is required because it was some reports about non unique names returned by Path.GetTempFileName()
            when running in multi-threaded environment. 
            (it is not used yet as I did not give up on PInvoke GetTempFileName())
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="F:csscript.CSExecutor.scriptArgs">
            <summary>
            C# Script arguments array (sub array of application arguments array).
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.print">
            <summary>
            Callback to print application messages to appropriate output.
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.options">
            <summary>
            Container for paresed command line parguments
            </summary>
        </member>
        <member name="F:csscript.CSExecutor.rethrow">
            <summary>
            Flag to force to rethrow critical exceptions
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.#ctor">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.#ctor(System.Boolean,csscript.CSExecutor.ExecuteOptions)">
            <summary>
            Constructor
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetAvailableAssembly(System.String)">
            <summary>
            Checks/returns if compiled C# script file (ScriptName + "c") available and valid.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.Compile(System.String)">
            <summary>
            Compiles C# script file.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.AddCompilerOptions(System.CodeDom.Compiler.CompilerParameters,System.String)">
            <summary>
            Adds compiler options to the CompilerParameters in a maner that it does separete every option by the space character
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ExecuteAssembly(System.String)">
            <summary>
            Executes compiled C# script file.
            Invokes static method 'Main' from the assembly.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.GetScriptTempDir">
            <summary>
            Returns the name of the temporary folder in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary directoiry name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.GetCacheDirectory(System.String)">
            <summary>
            Generates the name of the cache directory for the specified script file.
            </summary>
            <param name="file">Script file name.</param>
            <returns>Cache directory name.</returns>
        </member>
        <member name="M:csscript.CSExecutor.SetScriptCacheDir(System.String)">
            <summary>
            Generates the name of the temporary cache folder in the CSSCRIPT subfolder of Path.GetTempPath(). The cache folder is specifig for every script file.
            </summary>
            <param name="scriptFile">script file</param>
        </member>
        <member name="M:csscript.CSExecutor.ShowHelp">
            <summary>
            Prints Help info.
            </summary>
        </member>
        <member name="M:csscript.CSExecutor.ShowSample">
            <summary>
            Show sample C# scrip file.
            </summary>
        </member>
        <member name="P:csscript.CSExecutor.Rethrow">
            <summary>
            Force caught exceptions to be rethrown.
            </summary>
        </member>
        <member name="P:csscript.CSExecutor.ScriptCacheDir">
            <summary>
             Contains the name of the temporary cache folder in the CSSCRIPT subfolder of Path.GetTempPath(). The cache folder is specifig for every script file.
             </summary>
        </member>
        <member name="T:csscript.CSExecutor.ExecuteOptions">
            <summary>
            Application specific settings
            </summary>
        </member>
        <member name="T:csscript.MetaDataItems">
            <summary>
            The MetaDataItems class contains information about script dependencies (referenced local 
            assemblies and imported scripts) and copmpiler options. This information is required when 
            scripts are executed in a 'cached' mode (/c switch). On the base of this information the script 
            engine will compile new version of .csc assembly if any of it's dependencies is changed. This 
            is required even for referenced local assemblies as it is possible that they are a strongly 
            named assemblies (recompiling is required for any compiled client of the strongly named assembly 
            in case this assembly is changed). 
            
            The perfect place to store the dependencies info (custom meta data) is the assembly 
            resources. However if we do so such assemblies would have to be loaded in order to read their 
            resources. It is not acceptable as after loading assembly cannot be unloaded. Also assembly loading 
            can significantly compromise performance.
            
            That is why custom meta data is just physically appended to the file. This is a valid 
            approach because such assembly is not to be distributed anywhere but to stay always 
            on the PC and play the role of the temporary data for the script engine.
            
            Note: A .dll assembly is always compiled and linked in a normal way without any custom meta data attached. 
            </summary>
        </member>
        <member name="T:csscript.CompilerException">
            <summary>
            The exception that is thrown when a the script compiler error occurs.
            </summary>
        </member>
        <member name="M:csscript.CompilerException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
        </member>
        <member name="M:csscript.CompilerException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:csscript.CompilerException"/> class.
            </summary>
            <param name="message">The message.</param>
        </member>
        <member name="M:csscript.CompilerException.Create(System.CodeDom.Compiler.CompilerErrorCollection,System.Boolean)">
            <summary>
            Creates the CompilerException instance from the specified compiler errors errors.
            </summary>
            <param name="Errors">The compiler errors.</param>
            <param name="hideCompilerWarnings">if set to <c>true</c> hide compiler warnings.</param>
            <returns></returns>
        </member>
        <member name="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1">
            <summary>
                A utility class which converts an object to specified interface T. The object does
                not necessarily need to implement the interface formally.
            </summary>
            <typeparam name="T">Interface definition to convert to.</typeparam>
            <remarks>
            <para>
                Class Information:
                <list type="bullet">
                    <item name="authors">Authors: Ruben Hakopian</item>
                    <item name="date">March 2009</item>
                    <item name="originalURL">http://rubenhak.com/?p=167</item>
                </list>
            </para>
            </remarks>
        </member>
        <member name="F:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1._proxyCache">
            <summary>
            Represents a map from a object type to the type of its proxy class.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.As(System.Object,System.String[])">
            <summary>
            Converts specified object to an another object which implements interface T.
            </summary>
            <param name="o">The object to convert.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies 
            the interface depends in. </param>
            <returns>Converted object if succeeded; null otherwise.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.CheckSourceObject(System.Type,System.Type,System.String[])">
            <summary>
            Checks if the source type can be convert to destination interface type.
            </summary>
            <param name="interfaceType">The source type to convert from.</param>
            <param name="sourceType">The destination interface type to convert to.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies 
            the interface depends in. </param>
            <returns>true if conversion can be performed; false otherwise</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.CastToInterface(System.Type,System.Object,System.String[])">
            <summary>
            Creates an instance of an proxy object which implements interface T and wraps specified object.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="o">The object to convert.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies 
            the interface depends in. </param>
            <returns>Instance of the proxy object.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.BuildProxyClass(System.Type,System.Type,System.String[])">
            <summary>
            Builds the proxy class for specified interface and source types.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency assemblies 
            the interface depends in. </param>
            <returns>Type definition for proxy class.</returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClass(System.Type,System.Type)">
            <summary>
            Generates the proxy class.
            </summary>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
            <returns></returns>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassProperties(System.CodeDom.CodeTypeDeclaration,System.Type,System.Type)">
            <summary>
            Generates the proxy class properties.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassMethods(System.CodeDom.CodeTypeDeclaration,System.Type,System.Type)">
            <summary>
            Generates the proxy class methods.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="M:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster`1.GenerateProxyClassEvents(System.CodeDom.CodeTypeDeclaration,System.CodeDom.CodeConstructor,System.Type,System.Type)">
            <summary>
            Generates the proxy class events.
            </summary>
            <param name="genClass">The generated class.</param>
            <param name="constructor">The generated class constructor.</param>
            <param name="interfaceType">Type of the interface.</param>
            <param name="sourceType">Type of the source.</param>
        </member>
        <member name="T:CSScriptLibrary.Sandbox">
            <summary>
            Simple security helper class. This class is nothing else but a syntactic sugar.  
            <para>
            <example>The following is an example of execution under .NET sandbox:
            <code>
            Sandbox.With(SecurityPermissionFlag.Execution)
                   .Execute(() =>
                            {
                                //call sandboxed actions
                            });
            </code>
            </example>
            </para>
            </summary>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.Execute(System.Security.PermissionSet,System.Action)">
            <summary>
            Extension method. Executes <see cref="T:System.Action"/> with the specified array of permissions
            </summary>
            <param name="permissions">The permissions set to be used for the execution.</param>
            <param name="action">The action to be executed.</param>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With(System.Security.IPermission[])">
            <summary>
            Returns the specified permissions as <see cref="T:System.Security.PermissionSet"/> to be used with <see cref="T:CSScriptLibrary.Sandbox.Execute"/>.
            </summary>
            <param name="permissions">The permissions.</param>
            <returns><see cref="T:System.Security.PermissionSet"/> instance.</returns>
        </member>
        <member name="M:CSScriptLibrary.Sandbox.With(System.Security.Permissions.SecurityPermissionFlag)">
            <summary>
            Returns the specified permissions as <see cref="T:System.Security.PermissionSet"/> to be used with <see cref="T:csscript.Sandbox.Execute"/>.
            </summary>
            <param name="permissionsFlag">The permissions flag. Can be combination of multiple values.</param>
            <returns><see cref="T:System.Security.PermissionSet"/> instance.</returns>
        </member>
        <member name="T:CSScriptLibrary.ScriptedCodeAttribute">
            <summary>
            A custom assembly attribute automatically injected into script code. This attribute can be used to identify 
            calls to the host application routines made from script code.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.PrintDelegate">
            <summary>
            Delegate to handle output from script
            </summary>
        </member>
        <member name="T:CSScriptLibrary.CSScript">
            <summary>
            Class which is implements CS-Script class library interface.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.IsScriptAssembly(System.Reflection.Assembly)">
            <summary>
            Determines whether the specified assembly is a script assembly (compiled script). The analysis is based on the 
            fact that script assembly (in hosing scenarios) is always stamped with <see cref="T:CSScriptLibrary.ScriptedCodeAttribute"/>.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            	<c>true</c> if the specified assembly is a script assembly otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="F:CSScriptLibrary.CSScript.GlobalSettings">
            <summary>
            Settings object containing runtime settings, which controls script compilation/execution.
            This is Settings class essentially is a deserialized content of the CS-Script configuration file (css_config.xml). 
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.CompilingHistory">
            <summary>
            Collection of all compiling results. Every time the script is compiled the compiling result is added to this collection regardless of  
            the success or failure of the actual compilation.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Execute(CSScriptLibrary.PrintDelegate,System.String[])">
            <summary>
            Invokes global (static) CSExecutor (C# script engine)
            </summary>
            <param name="print">Print delegate to be used (if not null) to handle script engine output (eg. compilation errors).</param>
            <param name="args">Script arguments.</param>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Execute(CSScriptLibrary.PrintDelegate,System.String[],System.Boolean)">
            <summary>
            Invokes CSExecutor (C# script engine)
            </summary>
            <param name="print">Print delegate to be used (if not null) to handle script engine output (eg. compilation errors).</param>
            <param name="args">Script arguments.</param>
            <param name="rethrow">Flag, which indicated if script exceptions should be rethrowed by the script engine without any handling.</param>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileCode(System.String,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileCode(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptTempFile">
            <summary>
            Returns the name of the temporary file in the CSSCRIPT subfolder of Path.GetTempPath().
            </summary>
            <returns>Temporary file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetScriptTempDir">
            <summary>
            Returns the name of the CSScript temporary folder.
            </summary>
            <returns>Temporary folder name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Compile(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Compile(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor.
            This method is an equivalent of the CSScript.Compile(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,System.String)">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses specified config file to load script engine settings.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="cssConfigFile">The name of CS-Script configuration file. If null the default config file will be used (appDir/css_config.xml).</param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,System.String,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses specified config file to load script engine settings and compiler specific options.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="cssConfigFile">The name of CS-Script configuration file. If null the default config file will be used (appDir/css_config.xml).</param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler. </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.CompileWithConfig(System.String,System.String,System.Boolean,csscript.Settings,System.String,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor. Uses script engine settings object and compiler specific options.
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="scriptSettings">The script engine Settings object.</param>
            <param name="compilerOptions">The string value to be passed directly to the language compiler.  </param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly file name.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadMethod(System.String,System.String[])">
            <summary>
            Surrounds the method implementation code into a class and compiles it code into assembly with CSExecutor and loads it in current AppDomain.
            The most convenient way of using dynamic methods is to declare them as static methods. In this case they can be invoked with wild card character as a class name (e.g. asmHelper.Invoke("*.SayHello")). Otherwise you will need to instantiate class "DyamicClass.Script" in order to call dynamic method.
            
            You can have multiple methods implementations in the single methodCode. Also you can specify namespaces at the begining of the code:
            
            CSScript.LoadMethod(
                @"using System.Windows.Forms;
            
                public static void SayHello(string gritting)
                {
                    MessageBoxSayHello(gritting);
                    ConsoleSayHello(gritting);
                }
                public static void MessageBoxSayHello(string gritting)
                {
                    MessageBox.Show(gritting);
                }
                public static void ConsoleSayHello(string gritting)
                {
                    Console.WriteLine(gritting);
                }");
            </summary>
            <param name="methodCode">The C# code, containing method implementation.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadMethod(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Surrounds the method implementation code into a class and compiles it code into 
            assembly with CSExecutor and loads it in current AppDomain. The most convenient way of 
            using dynamic methods is to declare them as static methods. In this case they can be 
            invoked with wild card character as a class name (e.g. asmHelper.Invoke("*.SayHello")). 
            Otherwise you will need to instantiate class "DyamicClass.Script" in order to call dynamic method.
            
            
            You can have multiple methods implementations in the single methodCode. Also you can specify namespaces at the begining of the code:
            
            CSScript.LoadMethod(
                @"using System.Windows.Forms;
            
                public static void SayHello(string gritting)
                {
                    MessageBoxSayHello(gritting);
                    ConsoleSayHello(gritting);
                }
                public static void MessageBoxSayHello(string gritting)
                {
                    MessageBox.Show(gritting);
                }
                public static void ConsoleSayHello(string gritting)
                {
                    Console.WriteLine(gritting);
                }");
            </summary>
            <param name="methodCode">The C# code, containing method implementation.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadCode(System.String,System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script code into assembly with CSExecutor and loads it in current AppDomain.
            </summary>
            <param name="scriptText">The script code to be compiled.</param>
            <param name="tempFileExtension">The file extension of the temporary file to hold script code during compilation. This parameter may be 
            needed if custom CS-Script compilers rely on file extension to identify the script syntax.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String,System.String,System.Boolean,System.String[])">
            <summary>
            Compiles script file into assembly with CSExecutor and loads it in current AppDomain
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="assemblyFile">The name of compiled assembly. If set to null a temporary file name will be used.</param>
            <param name="debugBuild">'true' if debug information should be included in assembly; otherwise, 'false'.</param>
            /// <param name="refAssemblies">The string array containing file names to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String)">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor and loads it in current AppDomain.
            This method is an equivalent of the CSScript.Load(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.Load(System.String,System.String[])">
            <summary>
            Compiles script file into assembly (temporary file) with CSExecutor and loads it in current AppDomain.
            This method is an equivalent of the CSScript.Load(scriptFile, null, false);
            </summary>
            <param name="scriptFile">The name of script file to be compiled.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional assemblies referenced by the script. </param>
            <returns>Compiled/Loaded assembly.</returns>
        </member>
        <member name="M:CSScriptLibrary.CSScript.DefaultPrint(System.String)">
            <summary>
            Default implementation of displaying application messages.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.CacheEnabled">
            <summary>
            Controls if ScriptCache should be used when script file loading is requested (CSScript.Load(...)). If set to true and the script file was previously compiled and already loaded 
            the script engine will use that compiled script from the cache instead of compiling it again. 
            Note the script cache is always maintained by the script engine. The CacheEnabled property only indicates if the cached script should be used or not when CSScript.Load(...) method is called.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.GetCachedScriptAssembly(System.String)">
            <summary>
            Returns cached script assembly matching the scrpt file name. 
            </summary>
            <param name="file">Pull path of the script file.</param>
            <returns>Assembly loaded int the current AppDomain.
            Returns null if the loaded script cannot be found.
            </returns>
        </member>
        <member name="P:CSScriptLibrary.CSScript.Rethrow">
            <summary>
            Force caught exceptions to be re-thrown.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.AssemblyResolvingEnabled">
            <summary>
            Enables automatic resolving of unsuccessful assembly probing on the base of the Settings.SearchDirs.
            Default value is true.
            
            CLR does assembly probing only in GAC and in the local (with respect to the application) directories. CS-Script
            however allows you to specify extra directory(es) for assembly probing by setting enabling CS-Script assembly resolving 
            through setting the AssemblyResolvingEnabled to true and changing the Settings.SearchDirs appropriately.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ShareHostRefAssemblies">
            <summary>
            Gets or sets the assembly sharing mode. If set to true all assemblies (including the host assembly itself) 
            currently loaded to the host application AppDomain are automatically available/accessible from the script code.
            Default value is true.
            
            Sharing the same assembly set between the host application and the script require AssemblyResolvingEnabled to 
            be enabled. Whenever SharesHostRefAssemblies is changed to true it automatically sets AssemblyResolvingEnabled to
            true as well. 
            </summary>
        </member>
        <member name="P:CSScriptLibrary.CSScript.KeepCompilingHistory">
            <summary>
            Gets or sets a value indicating whether compiling history should be kept. The compilation results are stored in <see cref="F:CSScriptLibrary.CSScript.CompilingHistory"></see>. 
            </summary>
            <value>
            <c>true</c> if compiling history should be kept; otherwise, <c>false</c>.
            </value>
        </member>
        <member name="P:CSScriptLibrary.CSScript.ScriptCache">
            <summary>
            Cache of all loaded script files for the current process.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.CSScript.LoadedScript">
            <summary>
            LoadedScript is a class, which holds information about the script file location and it's compiled and loaded assmbly (current AppDomain). 
            </summary>
        </member>
        <member name="M:CSScriptLibrary.CSScript.LoadedScript.#ctor(System.String,System.Reflection.Assembly)">
            <summary>
            Creates instance of LoadedScript
            </summary>
            <param name="script">Script file location.</param>
            <param name="asm">Compiled script assembly loaded into current AppDomain.</param>
        </member>
        <member name="F:CSScriptLibrary.CSScript.LoadedScript.script">
            <summary>
            Script file location.
            </summary>
        </member>
        <member name="F:CSScriptLibrary.CSScript.LoadedScript.asm">
            <summary>
            Compiled script assembly loaded into current AppDomain.
            </summary>
        </member>
        <member name="T:csscript.CSSEnvironment">
            <summary>
            This class implements access to the CS-Script global configuration settings.
            </summary>
        </member>
        <member name="M:csscript.CSSEnvironment.GetCacheDirectory(System.String)">
            <summary>
            Generates the name of the cache directory for the specified script file.
            </summary>
            <param name="file">Script file name.</param>
            <returns>Cache directory name.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.SaveAsTempScript(System.String)">
            <summary>
            Saves code to the script file in the dedicated CS-Script <c>temporary files</c> location. You do not have to delete the script file after the execution. 
            It will be deleted as part of the periodical automatic CS-Script maintenance. 
            </summary>
            <param name="content">The script file content.</param>
            <returns>Name of the created temporary script file.</returns>
        </member>
        <member name="M:csscript.CSSEnvironment.GetTempScriptName">
            <summary>
            Generates the script file path in the dedicated CS-Script <c>temporary files</c> location. You do not have to delete such file after the execution. 
            It will be deleted as part of the periodical automatic CS-Script maintenance. 
            </summary>
            <returns>Name of the temporary script file.</returns>
        </member>
        <member name="P:csscript.CSSEnvironment.CacheDirectory">
            <summary>
            The directory where CS-Script engine keeps autogenerated files (subject of HideAutoGeneratedFiles setting).
            </summary>
        </member>
        <member name="P:csscript.CSSEnvironment.ScriptFile">
            <summary>
            The full name of the script file being executed.  
            </summary>
        </member>
        <member name="P:csscript.CSSEnvironment.PrimaryScriptFile">
            <summary>
            The full name of the primary script file being executed. Usually it is the sam file as ScriptFile. 
            However these fields are different if analysed from the pre/post-script.
            </summary>
        </member>
        <member name="T:csscript.AppInfo">
            <summary>
            Repository for application specific data
            </summary>
        </member>
        <member name="T:csscript.COM">
            <summary>
            COM HR checker: just to make code more compact;
            </summary>
        </member>
        <member name="T:csscript.IAssemblyCache">
            <summary>
            IAssemblyCache; COM import
            </summary>
        </member>
        <member name="T:csscript.IAssemblyName">
            <summary>
            IAssemblyName; COM import
            </summary>
        </member>
        <member name="T:csscript.IAssemblyEnum">
            <summary>
            IAssemblyEnum; COM import
            </summary>
        </member>
        <member name="T:csscript.AssemblyCommitFlags">
            <summary>
            AssemblyCommitFlags; Used by COM imported calls 
            </summary>
        </member>
        <member name="T:csscript.AssemblyCacheFlags">
            <summary>
            AssemblyCacheFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCacheUninstallDisposition">
            <summary>
            AssemblyCacheUninstallDisposition; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.CreateAssemblyNameObjectFlags">
            <summary>
            CreateAssemblyNameObjectFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyNameDisplayFlags">
            <summary>
            AssemblyNameDisplayFlags; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.InstallReference">
            <summary>
            InstallReference + struct initialization; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyInfo">
            <summary>
            AssemblyInfo; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.InstallReferenceGuid">
            <summary>
            InstallReferenceGuid; Used by COM imported calls
            </summary>
        </member>
        <member name="T:csscript.AssemblyCache">
            <summary>
             Helper calss for IAssemblyCache
            </summary>
        </member>
        <member name="T:csscript.AssemblyEnum">
            <summary>
            Helper calss for IAssemblyEnum
            </summary>
        </member>
        <member name="T:CSScriptLibrary.ParsingParams">
            <summary>
            ParsingParams is an class that holds parsing parameters (parameters that controls how file is to be parsed). 
            At this moment they are namespace renaming rules only.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ParsingParams.Compare(CSScriptLibrary.ParsingParams,CSScriptLibrary.ParsingParams)">
            <summary>
            Compare() is to be used to help with implementation of IComparer for sorting operations.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.ScriptInfo">
            <summary>
            Class which is a placeholder for general information of the script file
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptInfo.#ctor(csscript.CSharpParser.ImportInfo)">
            <summary>
            Constructor
            </summary>
            <param name="info">ImportInfo object containing the information how the script file should be parsed.</param>
        </member>
        <member name="T:CSScriptLibrary.FileParser">
            <summary>
            Class that implements parsing the single C# script file
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FileParser.ResolveFile(System.String,System.String[])">
            <summary>
            Searches for script file by given script name. Calls ResolveFile(string fileName, string[] extraDirs, bool throwOnError) 
            with throwOnError flag set to true.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FileParser.ResolveFile(System.String,System.String[],System.Boolean)">
            <summary>
            Searches for script file by given script name. Search order:
            1. Current directory
            2. extraDirs (usually %CSSCRIPT_DIR%\Lib and ExtraLibDirectory)
            3. PATH
            Also fixes file name if user did not provide extension for script file (assuming .cs extension)
            </summary>
        </member>
        <member name="T:CSScriptLibrary.FileParserComparer">
            <summary>
            Class that implements parsing the single C# Script file
            </summary>
            <summary>
            Implementation of the IComparer for sorting operations of collections of FileParser instances
            </summary>
            
        </member>
        <member name="T:CSScriptLibrary.ScriptParser">
            <summary>
            Class that manages parsing the main and all imported (if any) C# Script files
            </summary>
        </member>
        <member name="F:CSScriptLibrary.ScriptParser.apartmentState">
            <summary>
            ApartmentState of a script during the execution (default: ApartmentState.Unknown)
            </summary>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String,System.String[])">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.#ctor(System.String,System.String[],System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
            <param name="throwOnError">flag to indicate if the file parsing/processing error should raise an exception</param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.Init(System.String,System.String[])">
            <summary>
            Initialization of ScriptParser instance
            </summary>
            <param name="fileName">Script file name</param>
            <param name="searchDirs">Extra ScriptLibrary directory(ies) </param>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.SaveImportedScripts">
            <summary>
            Saves all imported scripts int temporary location. 
            </summary>
            <returns>Collection of the saved imported scrips file names</returns>
        </member>
        <member name="M:CSScriptLibrary.ScriptParser.DeleteImportedFiles">
            <summary>
            Deletes imported scripts as a cleanup operation
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.FilesToCompile">
            <summary>
            Colection of the files to be compiled (including dependand scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ImportedFiles">
            <summary>
            Colection of the imported files (dependand scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedResources">
            <summary>
            Collection of resource files referenced from code
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.CompilerOptions">
            <summary>
            Collection of compiler options
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedNamespaces">
            <summary>
            Collection of namespaces referenced from code (including those referenced in dependand scripts)
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.IgnoreNamespaces">
            <summary>
            Collection of namespaces, which if found in code, should not be resolved into referenced assembly.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.ScriptParser.ReferencedAssemblies">
            <summary>
            Collection of referenced asesemblies. All assemblies are referenced either from command-line, code or resolved from referenced namespaces.
            </summary>
        </member>
        <member name="T:CSScriptLibrary.AssemblyResolver">
            <summary>
            Class for resolving assembly name to assembly file
            </summary>
        </member>
        <member name="F:CSScriptLibrary.AssemblyResolver.ignoreFileName">
            <summary>
            File to be excluded from assembly search
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.ResolveAssembly(System.String,System.String)">
            <summary>
            Resolves assembly name to assembly file. Loads assembly file to the current AppDomain.
            </summary>
            <param name="assemblyName">The name of assembly</param>
            <param name="dir">The name of directory where local assemblies are expected to be</param>
            <returns>loaded assembly</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindAssembly(System.String,System.String[])">
            <summary>
            Resolves namespace/assembly(file) name into array of assembly locations (local and GAC ones).
            </summary>
            <param name="name">'namespace'/assembly(file) name</param>
            <param name="searchDirs">Assembly search directories</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindLocalAssembly(System.String,System.String)">
            <summary>
            Resolves namespace into array of local assembly locations.
            (Currently it returns only one assembly location but in future 
            it can be extended to collect all assemblies with the same namespace)
            </summary>
            <param name="name">namespace/assembly name</param>
            <param name="dir">directory</param>
            <returns>collection of assembly file names wher namespace is impelemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.FindGlobalAssembly(System.String)">
            <summary>
            Resolves namespace into array of global assembly (GAC) locations.
            </summary>
            <param name="namespaceStr">'namespace' name</param>
            <returns>collection of assembly file names where namespace is implemented</returns>
        </member>
        <member name="M:CSScriptLibrary.AssemblyResolver.IsNamespaceDefinedInAssembly(System.String,System.String)">
            <summary>
            Search for namespace into local assembly file.
            </summary>
        </member>
        <member name="T:csscript.CSharpParser">
            <summary>
            Very light paraser for C# code. The main purpose of it is to be very fast and reliable.
            It only extracts code information relative to the CS-Script.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="code">C# code string</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean)">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
        </member>
        <member name="M:csscript.CSharpParser.#ctor(System.String,System.Boolean,System.String[])">
            <summary>
            Creates an instance of CSharpParser.
            </summary>
            <param name="script">C# script (code or file).</param>
            <param name="isFile">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
        </member>
        <member name="F:csscript.CSharpParser.CustomDirectives">
            <summary>
            The result of search for additional C# script directives to search (directive vs. value).
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.Init(System.String,System.String)">
            <summary>
            Parses the C# code. Only one of the 'code' and 'file' parameters can be non empty.
            </summary>
            <param name="code">C# script code (empty string if code is in a file form).</param>
            <param name="file">The script file name (empty if code is in the text form).</param>
        </member>
        <member name="M:csscript.CSharpParser.Init(System.String,System.String,System.String[])">
            <summary>
            Parses the C# code.
            </summary>
            <param name="code">C# script (code or file).</param>
            <param name="file">If set to 'true' the script is a file, otherwise it is a C# code.</param>
            <param name="directivesToSearch">Additional C# script directives to search. The search result is stored in CSharpParser.CustomDirectives.</param>
        </member>
        <member name="M:csscript.CSharpParser.DoRenaming(System.String[][],System.Boolean)">
            <summary>
            Renames namespaces according renaming instructions.
            </summary>
            <param name="renamingMap">Renaming instructions (old_name vs. new_name).</param>
            <param name="preserveMain">/// If set to 'true' "static...Main" in the imported script is not renamed.</param>
        </member>
        <member name="P:csscript.CSharpParser.Args">
            <summary>
            Embedded script arguments. The both script and engine arguments are allowed except "/noconfig" engine command line switch.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.CompilerOptions">
            <summary>
            Embedded compiler options. 
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.References">
            <summary>
            References to the external assemblies and namespaces.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.RefAssemblies">
            <summary>
            References to the external assemblies.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.IgnoreNamespaces">
            <summary>
            Names of namespaces to be ignored by namespace-to-assembly resolver.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ExtraSearchDirs">
            <summary>
            Additional search directories (for script and assembly probing).
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ResFiles">
            <summary>
            References to the resource files.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.RefNamespaces">
            <summary>
            References to the namespaces.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Imports">
            <summary>
            C# scripts to be imported.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.CmdScripts">
            <summary>
            Pre- and post-execution scripts.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ThreadingModel">
            <summary>
            Appartment state of the script.
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.Code">
            <summary>
            Script C# raw code. 
            </summary>
        </member>
        <member name="P:csscript.CSharpParser.ModifiedCode">
            <summary>
            Script C# code after namespace renaming. 
            </summary>
        </member>
        <member name="T:csscript.CSharpParser.CmdScriptInfo">
            <summary>
            Class to hold the script information on what pre- or post-execution script needs to be executed.
            pre- and post-script CS-Script command format:
            //css_prescript file([arg0][, arg1]..[,arg2])[,ignore];
            //file - script file (extension is optional)		
            //arg0..N - script string arguments; 
            If $this is specified as arg0..N it will be replaced with the parent script full name at execution time.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.CmdScriptInfo.#ctor(System.String,System.Boolean,System.String)">
            <summary>
            Creates an instance of CmdScriptInfo.
            </summary>
            <param name="statement">CS-Script pre- or post-script directive</param>
            <param name="preScript">If set to true the 'statement' is a pre-script otherwise it is a post-script.</param>
            <param name="parentScript">The file name of the main script.</param>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.args">
            <summary>
            Script file and it's arguments.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.preScript">
            <summary>
            If set to 'true' the CmdScriptInfo describes the pre-script, otherwise it is for the post-script.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.CmdScriptInfo.abortOnError">
            <summary>
            If set to 'true' parent script will be aborted on pre/post-script error, otherwise the error will be ignored.
            </summary>
        </member>
        <member name="T:csscript.CSharpParser.ImportInfo">
            <summary>
            Class to hold the script importing information, which actually controls how script is imported.
            </summary>
        </member>
        <member name="M:csscript.CSharpParser.ImportInfo.#ctor(System.String,System.String)">
            <summary>
            Creates an instance of ImportInfo.
            </summary>
            <param name="statement">CS-Script import directive (//css_import...) string.</param>
            <param name="parentScript">name of the parent (primary) script file.</param>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.file">
            <summary>
            The file to be imporeted.
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.renaming">
            <summary>
            Renaming instructions (old_name vs. new_name)
            </summary>
        </member>
        <member name="F:csscript.CSharpParser.ImportInfo.preserveMain">
            <summary>
            If set to 'true' "static...Main" in the imported script is not renamed.
            </summary>
        </member>
        <member name="T:CSScriptLibraryExtensionMethods">
            <summary>
            Method extensions for 
            </summary>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.IsScriptAssembly(System.Reflection.Assembly)">
            <summary>
            Determines whether the specified assembly is a script assembly (compiled script). The analysis is based on the 
            fact that script assembly (in hosing scenarios) is always stamped with <see cref="T:CSScriptLibrary.ScriptedCodeAttribute"/>.
            </summary>
            <param name="assembly">The assembly.</param>
            <returns>
            	<c>true</c> if the specified assembly is a script assembly otherwise, <c>false</c>.
            </returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetHelper(System.Reflection.Assembly)">
            <summary>
            Constructs and returns an instance of CSScriptLibrary.AsmHelper class from the underlying Assembly.
            </summary>
            <returns>CSScriptLibrary.AsmHelper</returns>
            <param name="obj">Instance of the type to be extended</param>
            <returns>CSScriptLibrary.AsmHelper</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod(System.Reflection.Assembly,System.String,System.Object[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild 
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments. 
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker 
            can be obtained as following:
            <para>
            GetStaticMethod("Calc.Sum", 0, 0)
            </para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the 
            information about the paramater type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethodWithArgs(System.Reflection.Assembly,System.String,System.Type[])">
            <summary>
            Returns which emitted delegate based on MethodInfo of the underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild 
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even *.*).</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.GetStaticMethod(System.Reflection.Assembly)">
            <summary>
            <param name="obj">Instance of the type to be extended</param>
            Specialised version of GetMethodInvoker which returns MethodDelegate of the very first method found in the 
            underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            
            Use thids method when script assembly contains only one single type with one method.
            </summary>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryCreateObject(System.Reflection.Assembly,System.String)">
            <summary>
            Attempts to create instance of a class from underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Instance of the 'Type'. Returns null if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.CreateObject(System.Reflection.Assembly,System.String)">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="obj">Instance of the type to be extended</param>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object)">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.TryAlignToInterface``1(System.Object,System.String[])">
            <summary>
            Attempts to align (pseudo typecast) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency 
            assemblies the interface depends in. </param>
            <returns>Interface object or <c>null</c> if alignment was unsuccessful.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/>
            when emitting (compiling) aligned proxy object.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency 
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibraryExtensionMethods.AlignToInterface``1(System.Object)">
            <summary>
            Aligns (pseudo typecasts) object to interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="T:CSScriptLibrary.FastInvokeDelegate">
            <summary>
            Delegate which is used as a return type for AsmHelper.GetMethodInvoker(). 
            
            AsmHelper.GetMethodInvoker() allows obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
            </summary>
            <param name="instance">Instance of the type which method is to be invoked.</param>
            <param name="paramters">Optional method parameters.</param>
            <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.MethodDelegate">
            <summary>
            Delegate which is used as a return type for AsmHelper.GetMethodInvoker(). 
            
            AsmHelper.GetStaticMethod() and AsmHelper.GetMethod() allow obtaining dynamic method delegate emitted on the base of the MethodInfo (from the compiled script type).
            </summary>
            <param name="paramters">Optional method parameters.</param>
            <returns>Returns MethodInfo return value</returns>
        </member>
        <member name="T:CSScriptLibrary.AsmHelper">
            <summary>
            Helper class to simplify working with dynamically loaded assemblies. 
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object)">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working 
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual 
            interface allignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object,System.String[])">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working 
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual 
            interface allignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="refAssemblies">The string array containing file nemes to the additional dependency 
            assemblies the interface depends in. </param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.AlignToInterface``1(System.Object,System.Boolean)">
            <summary>
            Aligns (pseudo typecasts) object to the specified interface.
            <para>The object does not necessarily need to implement the interface formally.</para>
            <para>See <see cref="T:CSScriptLibrary.ThirdpartyLibraries.Rubenhak.Utils.ObjectCaster"/>.</para>
            <remarks>
            The important difference between this method being called from <see cref="T:CSScriptLibrary.AsmHelper"/> working 
            with the assembly in current and remote <see cref="T:System.AppDomain"/> is that is that the actual 
            interface allignment is performed in the corresponding <see cref="T:System.AppDomain"/>.
            </remarks>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="obj">The object to be aligned with the interface.</param>
            <param name="useAppDomainAssemblies">If set to <c>true</c> uses all loaded assemblies of the current <see cref="T:System.AppDomain"/></param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.CreateAndAlignToInterface``1(System.String)">
            <summary>
            Creates object in remote or current <see cref="T:System.AppDomain"/> and aligns (pseudo typecasts) it to the specified interface.
            <para>Semantecally it is an equivalent of calling 
            <code>asmHelper.AlignToInterface(asmHelper.CreateObject(typeName))</code>
            </para>
            </summary>
            <typeparam name="T">Interface definition to align with.</typeparam>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Interface object.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethodInvoker(System.String,System.Object[])">
            <summary>
            This method returns extremely fast delegate for the method specified by "methodName" and 
            method arguments "list". Ivoking such delegate is ~100 times faster than invoking with pure reflection 
            (MethodInfo.Invoke()). 
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild 
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. 
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker 
            can be obtained as following:
            <para></para>
            GetMethodInvoker("Calc.Sum", 0, 0)
            <para></para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the 
            information about the paramater type (in this case System.Int32).</param>
            <returns>Returns delegate of CSScriptLibrary.FastInvokeDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod(System.String,System.Object[])">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild 
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
            <remarks>
            <para>
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker 
            can be obtained as following:
            </para>
            </para>
            <example>
            <code>GetStaticMethod("Calc.Sum", 0, 0)</code>
            </example>
            <para>
            You can pass any integer as the second and third parameter because it will be used only to obtain the 
            information about the paramater type (in this case System.Int32).
            </para>
            </remarks>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethodWithArgs(System.String,System.Type[])">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance (null) when calling static methods.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild 
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetStaticMethod">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate of the very first method found in the 
            underlying assembly. This method is an overloaded implementation of the GetStaticMethod(string methodName, params object[] list).
            <para>
            Use thids method when script assembly contains only one single type with one method.
            </para>
            </summary>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.GetMethod(System.Object,System.String,System.Object[])">
            <summary>
            Specialised version of GetMethodInvoker which returns MethodDelegate thus you do not need to specify
            object instance when calling instance methods as delegate will maintain the instance object internaly.
            </summary>
            <param name="instance">Instance of the type, which implements method is to be wrapped by MethodDelegate.</param>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild 
            card character to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or "*.*").</param>
            <param name="list">List of 'Method' arguments. 
            <para>
            Note that values of the items in the list do not have any importance. The type of the list item is
            to be used for method search. For example if class Calc has method Sum(int a, int b) the method invoker 
            can be obtained as following:
            <code>
            GetMethod(instance, "Sum", 0, 0)
            </code>
            You can pass any integer as the second and third parameter because it will be used only to obtain the 
            information about the paramater type (in this case System.Int32).
            </para>
            </param>
            <returns>Returns delegate of CSScriptLibrary.MethodDelegate type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.#ctor(System.Reflection.Assembly)">
            <summary>
            Creates an instance of AsmHelper for working with assembly dynamically loaded to current AppDomain. 
            Calling "Dispose" is optional for "current AppDomain"scenario as no new AppDomain will be ever created.
            </summary>
            <param name="asm">Assembly object.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.#ctor(System.String,System.String,System.Boolean)">
            <summary>
            Creates an instance of AsmHelper for working with assembly dynamically loaded to non-current AppDomain. 
            This mathod initialises instance and creates new ('remote') AppDomain with 'domainName' name. New AppDomain is automatically unloaded as result of "disposable" behaviour of AsmHelper.
            </summary>
            <param name="asmFile">File name of the assembly to be loaded.</param>
            <param name="domainName">Name of the domain to be created.</param>
            <param name="deleteOnExit">'true' if assembly file should be deleted when new AppDomain is unloaded; otherwise, 'false'.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Invoke(System.String,System.Object[])">
            <summary>
            Executes static method of the underlying assembly.
            </summary>
            <param name="methodName">'Method' name including 'Type' name (eg. MyType.DoJob). It is allowd to use wild card character
            to indicate that the Type name of the method is irrelevant (e.g. "*.Method").</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns object of the same type as 'Method' return type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.InvokeInst(System.Object,System.String,System.Object[])">
            <summary>
            Executes an instance method of the underlying assembly.
            </summary>
            <param name="obj">Instance of the object whos method is to be invoked.</param>
            <param name="methodName">'Method' name (exccluding 'Type' name). It is allowed to use wild card character
            to indicate that the Type name of the method is irrelevant (e.g. "*.Method" or even "*.*").</param>
            <param name="list">List of 'Method' arguments.</param>
            <returns>Returns object of the same type as 'Method' return type.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.TryCreateObject(System.String)">
            <summary>
            Attempts to create instance of a class from underlying assembly.
            </summary>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Instance of the 'Type'. Returns null if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.CreateObject(System.String)">
            <summary>
            Creates instance of a class from underlying assembly.
            </summary>
            <param name="typeName">The 'Type' full name of the type to create. (see Assembly.CreateInstance()).
            You can use wild card meaning the first type found. However only full wild card "*" is supported.</param>
            <returns>Instance of the 'Type'. Throws an ApplicationException if the instance cannot be created.</returns>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Unload">
            <summary>
            Unloads 'remote' AppDomain if it was created.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Dispose">
            <summary>
            Implementation of IDisposable.Dispose(). Disposes allocated exetrnal resources if any. Call this method to unload non-current AppDomain (if it was created).
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Dispose(System.Boolean)">
            <summary>
            Actual implementation of IDisposable.Dispose()
            </summary>
            <param name="disposing">'false' if the method has been called by the runtime from inside the finalizer ; otherwise, 'true'.</param>
        </member>
        <member name="M:CSScriptLibrary.AsmHelper.Finalize">
            <summary>
            Finalizer
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.ScriptExecutionDomain">
            <summary>
            Instance of the AppDomain, which is used to execute the script. 
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.CachingEnabled">
            <summary>
            Flag that indicates if method caching is enabled. It is set to true by default.
            <para></para>
            When caching is enabled AsmHelper generates (emits) extremely fast delegates for 
            the methods being invoked. If AsmHelper is in cache mode it performs more than twice faster.
            However generation of the delegate does take some time that is why you may consider 
            switching caching off if the method is to be invoked only once.
            </summary>
        </member>
        <member name="P:CSScriptLibrary.AsmHelper.ProbingDirs">
             <summary>
            Array of directories to be used for assembly probing. 
             </summary>
        </member>
        <member name="T:CSScriptLibrary.IAsmBrowser">
            <summary>
            Defines method for calling assembly methods and instantiating assembly types.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.AsmBrowser.CreateInstance(System.String)">
            <summary>
            Creates instance of a Type from underying assembly.
            </summary>
            <param name="typeName">Name of the type to be instantiated. Allows wild card character (e.g. *.MyClass can be used to instantiate MyNamespace.MyClass).</param>
            <returns>Created instance of the type.</returns>
        </member>
        <member name="T:CSScriptLibrary.FastInvoker">
            <summary>
            Class which is capable of emitting the dynamic method delegate based on the MethodInfo. Such delegate is
            extremely fast and it can demonstrate up to 100 times better performance comparing to the pure 
            Reflection method invokation (MethodInfo.Invoke()).
            
            
            Based on http://www.codeproject.com/KB/cs/FastInvokerWrapper.aspx
            </summary>
        </member>
        <member name="F:CSScriptLibrary.FastInvoker.info">
            <summary>
            Methodinfo instance which was used to generate dynamic method delegate.
            </summary>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.#ctor(System.Reflection.MethodInfo)">
            <summary>
            Constructor  
            </summary>
            <param name="info">Methodinfo instance which is to be used to generate dynamic method delegate.</param>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.Invoke(System.Object,System.Object[])">
            <summary>
            Invokes dynamic method delegate generated from the MethodInfo object.
            </summary>
            <param name="instance">Instance of the type which method is to be invoked.</param>
            <param name="paramters">Optional method parameters.</param>
            <returns>Invokes dynamic method delegate return value</returns>
        </member>
        <member name="M:CSScriptLibrary.FastInvoker.GetMethodInvoker">
            <summary>
            Returns dynamic method delegate generated from the MethodInfo object.
            </summary>
            <returns>FastInvokeDelegate instance.</returns>
        </member>
    </members>
</doc>
