<?xml version="1.0"?>
<doc>
    <assembly>
        <name>SD.LLBLGen.Pro.DQE.SqlServer</name>
    </assembly>
    <members>
        <member name="T:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine">
            <summary>
            DynamicQueryEngine for SqlServer.
            </summary>
        </member>
        <member name="F:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.ServerInvariantProviderName">
            <summary>
            Invariant name for obtaining the factory for SqlServer's SqlClient, the client used when connecting to the server/Express/MSDE variant of SqlServer
            </summary>
        </member>
        <member name="F:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.Ce3xInvariantProviderName">
            <summary>
            Invariant name for obtaining the factory for SqlServer CE Desktop's Ce client for SqlServer Ce v3.0 or v3.1
            </summary>
        </member>
        <member name="F:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.Ce35InvariantProviderName">
            <summary>
            Invariant name for obtaining the factory for SqlServer CE Desktop's Ce client for SqlServer Ce v3.5 and up.
            </summary>
        </member>
        <member name="F:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.ArithAbortOn">
            <summary>
            Flag to signal the DQE to generate SET ARITHABORT ON statements prior to INSERT, DELETE and UPDATE Queries.
            Keep this flag to false in normal usage, but set it to true if you need to write into a table which is part of an indexed view.
            It will not affect normal inserts/updates that much, leaving it on is not harmful. Please consult SqlServer's Books online for 
            more details on SET ARITHABORT ON. After each statement the setting is turned off if it has been turned on prior to that statement.
            </summary>
            <remarks>Setting this flag is a global change. Not supported on CE</remarks>
        </member>
        <member name="F:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.UseNoLockHintOnSelects">
            <summary>
            Flag to signal the DQE to tell the SqlServerSpecificCreator to create WITH NOLOCK hints on table references in select queries for FROM clauses.
            WITH NOLOCK is not recommended though in high volume databases with a lot of rows, it can be a lot of blocking can occur because SqlServer forces
            readers to block writers and vice versa. Please consult the SqlServer's Book online for more information about this hint and also the downsides
            for using it. The setting is global and for all select queries. Default is false and it should only be set to true in those situations in which
            no other option is available.
            </summary>
            <remarks>Setting this flag is a global change.</remarks>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.#ctor">
            <summary>
            Creates a new <see cref="T:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine"/> instance.
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.#cctor">
            <summary>
            Static CTor for initializing TraceSwitch and name overwrites
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateFunctionMappingStore">
            <summary>
            Creates the function mappings for this DQE.
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateSingleTargetInsertDQ(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,System.Collections.Generic.Dictionary{SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore,System.Data.IDataParameter}@)">
            <summary>
            Creates a new Insert Query object which is ready to use. 
            </summary>
            <param name="fields">Array of EntityFieldCore objects to use to build the insert query</param>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the insert query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="fieldToParameter">Hashtable which will contain after the call for each field the parameter which contains or will contain the field's value.</param>
            <returns>IActionQuery Instance which is ready to be used.</returns>
            <remarks>Generic version.</remarks>
            <exception cref="T:System.ArgumentNullException">When fields is null or fieldsPersistenceInfo is null</exception>
            <exception cref="T:System.ArgumentException">When fields contains no EntityFieldCore instances or fieldsPersistenceInfo is empty.</exception>
            <exception cref="T:SD.LLBLGen.Pro.ORMSupportClasses.ORMQueryConstructionException">When there are no fields to insert in the fields list. This exception is to prevent 
            INSERT INTO table () VALUES () style queries.</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateSingleTargetDeleteDQ(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,SD.LLBLGen.Pro.ORMSupportClasses.IPredicate)">
            <summary>
            Creates a new Delete Query object which is ready to use.
            </summary>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the delete query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="deleteFilter">A complete IPredicate implementing object which contains the filter for the rows to delete</param>
            <returns>IActionQuery instance which is ready to be used.</returns>
            <remarks>Generic version</remarks>
            <exception cref="T:System.ArgumentNullException">When persistenceInfo is null</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateSingleTargetDeleteDQ(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,SD.LLBLGen.Pro.ORMSupportClasses.IPredicate,SD.LLBLGen.Pro.ORMSupportClasses.IRelationCollection)">
            <summary>
            Creates a new Delete Query object which is ready to use.
            </summary>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the delete query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="deleteFilter">A complete IPredicate implementing object which contains the filter for the rows to delete</param>
            <param name="relationsToWalk">list of EntityRelation objects, which will be used to formulate a second FROM clause with INNER JOINs.</param>
            <returns>IActionQuery instance which is ready to be used.</returns>
            <remarks>Generic version</remarks>
            <exception cref="T:System.ArgumentNullException">When persistenceInfo is null or when deleteFilter is null or when relationsToWalk is null</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateSingleTargetUpdateDQ(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,SD.LLBLGen.Pro.ORMSupportClasses.IPredicate)">
            <summary>
            Creates a new Update Query object which is ready to use. Only 'changed' EntityFieldCore fields are included in the update query. 
            Primary Key fields are never updated. 
            </summary>
            <param name="fields">EntityFieldCore array to use to build the update query.</param>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the update query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="updateFilter">A complete IPredicate implementing object which contains the filter for the rows to update</param>
            <returns>IActionQuery instance which is ready to be used.</returns>
            <exception cref="T:System.ArgumentNullException">When fields is null or fieldsPersistenceInfo is null</exception>
            <exception cref="T:System.ArgumentException">When fields contains no EntityFieldCore instances or fieldsPersistenceInfo is empty.</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateSingleTargetUpdateDQ(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,SD.LLBLGen.Pro.ORMSupportClasses.IPredicate,SD.LLBLGen.Pro.ORMSupportClasses.IRelationCollection)">
            <summary>
            Creates a new Update Query object which is ready to use. Only 'changed' EntityFieldCore are included in the update query.
            Primary Key fields are never updated. 
            </summary>
            <param name="fields">Array of EntityFieldCore objects to use to build the insert query</param>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the update query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="updateFilter">A complete IPredicate implementing object which contains the filter for the rows to update</param>
            <param name="relationsToWalk">list of EntityRelation objects, which will be used to formulate a FROM clause with INNER JOINs.</param>
            <returns>IActionQuery instance which is ready to be used.</returns>
            <exception cref="T:System.ArgumentNullException">When fields is null or when updateFilter is null or 
            when relationsToWalk is null or when fieldsPersistence is null</exception>
            <exception cref="T:System.ArgumentException">When fields contains no EntityFieldCore instances or fieldsPersistenceInfo is empty.</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateSelectDQ(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,SD.LLBLGen.Pro.ORMSupportClasses.IPredicate,System.Int64,SD.LLBLGen.Pro.ORMSupportClasses.ISortExpression,SD.LLBLGen.Pro.ORMSupportClasses.IRelationCollection,System.Boolean,SD.LLBLGen.Pro.ORMSupportClasses.IGroupByCollection,System.Boolean,System.Boolean)">
            <summary>
            Creates a new Select Query which is ready to use, based on the specified select list and the specified set of relations.
            If selectFilter is set to null, all rows are selected.
            </summary>
            <param name="selectList">list of IEntityFieldCore objects to select</param>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the select query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="selectFilter">A complete IPredicate implementing object which contains the filter for the rows to select. When set to null, no 
            filtering is done, and all rows are returned.</param>
            <param name="maxNumberOfItemsToReturn"> The maximum number of items to return with this retrieval query. 
            If the used Dynamic Query Engine supports it, 'TOP' is used to limit the amount of rows to return. 
            When set to 0, no limitations are specified.</param>
            <param name="sortClauses">The order by specifications for the sorting of the resultset. When not specified, no sorting is applied.</param>
            <param name="relationsToWalk">list of EntityRelation objects, which will be used to formulate a FROM clause with INNER JOINs.</param>
            <param name="allowDuplicates">Flag which forces the inclusion of DISTINCT if set to true. If the resultset contains fields of type ntext, text or image, no duplicate filtering
            is done.</param>
            <param name="groupByClause">The list of fields to group by on. When not specified or an empty collection is specified, no group by clause
            is added to the query. A check is performed for each field in the selectList. If a field in the selectList is not present in the groupByClause
            collection, an exception is thrown.</param>
            <param name="relationsSpecified">flag to signal if relations are specified, this is a result of a check. This routine should
            simply assume the value of this flag is correct.</param>
            <param name="sortClausesSpecified">flag to signal if sortClauses are specified, this is a result of a check. This routine should
            simply assume the value of this flag is correct.</param>
            <returns>IRetrievalQuery instance which is ready to be used.</returns>
            <exception cref="T:System.ArgumentNullException">When selectList is null or fieldsPersistenceInfo is null</exception>
            <exception cref="T:System.ArgumentException">When selectList contains no EntityFieldCore instances or fieldsPersistenceInfo is empty.</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreatePagingSelectDQ(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Data.IDbConnection,SD.LLBLGen.Pro.ORMSupportClasses.IPredicate,System.Int64,SD.LLBLGen.Pro.ORMSupportClasses.ISortExpression,SD.LLBLGen.Pro.ORMSupportClasses.IRelationCollection,System.Boolean,SD.LLBLGen.Pro.ORMSupportClasses.IGroupByCollection,System.Int32,System.Int32)">
            <summary>
            Creates a new Select Query which is ready to use, based on the specified select list and the specified set of relations.
            If selectFilter is set to null, all rows are selected.
            </summary>
            <param name="selectList">list of IEntityFieldCore objects to select</param>
            <param name="fieldsPersistenceInfo">Array of IFieldPersistenceInfo objects to use to build the select query</param>
            <param name="connectionToUse">The connection to use for the query</param>
            <param name="selectFilter">A complete IPredicate implementing object which contains the filter for the rows to select. When set to null, no 
            filtering is done, and all rows are returned.</param>
            <param name="maxNumberOfItemsToReturn"> The maximum number of items to return with this retrieval query. 
            If the used Dynamic Query Engine supports it, 'TOP' is used to limit the amount of rows to return. 
            When set to 0, no limitations are specified.</param>
            <param name="sortClauses">The order by specifications for the sorting of the resultset. When not specified, no sorting is applied.</param>
            <param name="relationsToWalk">list of EntityRelation objects, which will be used to formulate a FROM clause with INNER JOINs.</param>
            <param name="allowDuplicates">Flag which forces the inclusion of DISTINCT if set to true. If the resultset contains fields of type ntext, text or image, no duplicate filtering
            is done.</param>
            <param name="groupByClause">The list of fields to group by on. When not specified or an empty collection is specified, no group by clause
            is added to the query. A check is performed for each field in the selectList. If a field in the selectList is not present in the groupByClause
            collection, an exception is thrown.</param>
            <param name="pageNumber">the page number to retrieve. First page starts with 1. If set to 0 or lower, no paging logic is applied</param>
            <param name="pageSize">the page size to retrieve. If set to 0 no paging logic is applied.</param>
            <returns>IRetrievalQuery instance which is ready to be used.</returns>
            <remarks>Generic version</remarks>
            <exception cref="T:System.ArgumentNullException">When selectList is null or fieldsPersistenceInfo is null or relationsToWalk is null</exception>
            <exception cref="T:System.ArgumentException">When selectList contains no EntityFieldCore instances or fieldsPersistenceInfo is empty.</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.GetNewCatalogName(System.String)">
            <summary>
            Gets the new name for the catalog, given the current name. If the current name is not found in the list of catalog name overwrites, 
            the current name is returned. This routine works on the catalog names specified in the config file.
            </summary>
            <param name="currentName">Name of the current.</param>
            <returns>New name for the catalog which name was passed in.</returns>
            <remarks>Thread safe, because the hashtable is never modified during execution.</remarks>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.GetNewSchemaName(System.String)">
            <summary>
            Gets the new name for the schema, given the current name. If the current name is not found in the list of schema name overwrites, 
            the current name is returned. This routine works on the schema names specified in the config file.
            </summary>
            <param name="currentName">current Name</param>
            <returns>New name for the schema which name was passed in.</returns>
            <remarks>Thread safe, because the hashtable is never modified during execution.</remarks>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.GetNewStoredProcedureName(System.String)">
            <summary>
            Gets the new name of the stored procedure passed in. Overwrites schema and catalog name with a new name if these names
            have been defined for overwriting. This routine works on the catalog and schema names specified in the config file.
            </summary>
            <param name="currentName">current Name</param>
            <remarks>Thread safe, because the hashtable is never modified during execution.</remarks>
            <returns>full stored procedure name with new catalog name/schema name.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.GetNewPerCallStoredProcedureName(System.String)">
            <summary>
            Gets the new name of the stored procedure passed in. Overwrites schema and catalog name with a new name if these names
            have been defined for overwriting.  This routine works on the PerCallCatalogNameOverwrites and PerCallSchemaNameOverwrites names specified on this instance
            </summary>
            <param name="currentName">current Name</param>
            <remarks>Thread safe, because the hashtable is never modified during execution.</remarks>
            <returns>full stored procedure name with new catalog name/schema name.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.ManglePageSelectDQ(SD.LLBLGen.Pro.ORMSupportClasses.IRetrievalQuery@,SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],SD.LLBLGen.Pro.ORMSupportClasses.ISortExpression,System.Int32,System.Int32)">
            <summary>
            Creates a CTE using paging query for SqlServer 2005 or higher.
            </summary>
            <param name="selectQuery">the actual query to page over.</param>
            <param name="selectList">The select list.</param>
            <param name="fieldsPersistenceInfo">The fields persistence info.</param>
            <param name="sortClauses">The sort clauses.</param>
            <param name="pageNumber">The page number.</param>
            <param name="pageSize">Size of the page.</param>
            <remarks>Query structure:
            <pre>
            WITH __actualSet AS
            (
                SELECT *, ROW_NUMBER() OVER(ORDER BY CURRENT_TIMESTAMP) AS __rowcnt
                FROM
            	(
            		SELECT DISTINCT TOP (pagenumber * pagesize)+1, selectlist
            		FROM ...
            	) AS _tmpSet
            )
            SELECT * FROM __actualSet
            WHERE __rowcnt BETWEEN startCnt AND endCount
            ORDER BY __rowcnt ASC
            </pre>
            And sortclause refers to the fields in the _tmpSet, instead of having the full order by again. 
            </remarks>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.ManglePageSelectDQ(SD.LLBLGen.Pro.ORMSupportClasses.IRetrievalQuery@,SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],System.Int32,System.Int32)">
            <summary>
            Mangles the page select d q.
            </summary>
            <param name="selectQuery">Select query.</param>
            <param name="selectList">Select list.</param>
            <param name="persistenceInfo">Persistence info.</param>
            <param name="pageNumber">Page number.</param>
            <param name="pageSize">Size of the page.</param>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateColumn(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore)">
            <summary>
            Creates the column.
            </summary>
            <param name="persistenceInfo">Persistence info.</param>
            <param name="sourceField">The source field.</param>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateExceptionInfoRetriever">
            <summary>
            Creates the exception info retriever for this DQE
            </summary>
            <returns>
            the db specific exception info retriever object.
            </returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateCommand">
            <summary>
            Creates a new IDbCommand object and initializes it
            </summary>
            <returns>ready to use IDbCommand object</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateDbSpecificCreator">
            <summary>
            Creates a new IDbSpecificCreator and initializes it
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.IsCe">
            <summary>
            Determines whether this instance is set to target CE.
            </summary>
            <returns>true if compatibility level is set to a CE version, otherwise false.
            </returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CreateParameterInstance">
            <summary>
            Creates the parameter instance.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.SetOutputParameterDirection">
            <summary>
            Sets the output parameter direction.
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.SetFactoryToUse">
            <summary>
            Sets the factory to use.
            </summary>
        </member>
        <member name="P:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.CompatibilityLevel">
            <summary>
            Compatibility level used by the DQE. Default is SqlServer2000. To utilize SqlServer 2005 specific features, set this parameter 
            to SqlServer2005, either through a setting in the .config file of your application or by setting this parameter once in your application.
            Compatibility level influences the query generated for paging, sequence name (@@IDENTITY/SCOPE_IDENTITY()), and usage of newsequenceid() in inserts. 
            It also influences the provider to use. This way you can switch between SqlServer server client 'SqlClient' and SqlServer CE Desktop. 
            </summary>
            <remarks>Setting this property will overrule a similar setting in the .config file. Don't set this property when queries are executed as
            it might switch factories for ADO.NET elements which could result in undefined behavior. Set this property at startup of your application as it's
            a global setting (affects all queries in your application using this DQE)</remarks>
        </member>
        <member name="P:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.FactoryToUse">
            <summary>
            Gets the DbProviderFactory to use, which is controlled by the compatibility level. 
            </summary>
        </member>
        <member name="P:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.FunctionMappings">
            <summary>
            Gets the function mappings for the particular DQE. These function mappings are static and therefore not changeable.
            </summary>
        </member>
        <member name="P:SD.LLBLGen.Pro.DQE.SqlServer.DynamicQueryEngine.Creator">
            <summary>
            Gets / sets creator
            </summary>
            <value></value>
        </member>
        <member name="T:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator">
            <summary>
            Implements IDbSpecificCreator for SqlServer. 
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.#ctor">
            <summary>
            CTor
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateParameter(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore,SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a valid Parameter based on the passed in IEntityFieldCore implementation and the passed in IFieldPersistenceInfo instance
            </summary>
            <param name="field">IEntityFieldCore instance used to base the parameter on.</param>
            <param name="persistenceInfo">Persistence information to create the parameter.</param>
            <param name="direction">The direction for the parameter</param>
            <param name="valueToSet">Value to set the parameter to.</param>
            <returns>Valid parameter for usage with the target database.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateFilledParameter(System.String,System.Data.SqlDbType,System.Int32,System.Data.ParameterDirection,System.Boolean,System.Byte,System.Byte,System.Object)">
            <summary>
            Creates a new, filled parameter.
            </summary>
            <param name="parameterName">Name of the parameter.</param>
            <param name="dbTypeToUse">The db type to use.</param>
            <param name="size">The size.</param>
            <param name="direction">The direction.</param>
            <param name="isNullable">if set to <c>true</c> [is nullable].</param>
            <param name="precision">The precision.</param>
            <param name="scale">The scale.</param>
            <param name="value">The value.</param>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateParameter(System.String,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a parameter based on the fieldcore passed in and the value passed in. The value is used to determine the DB type. 
            No precision/scale/length is set, this is left to the IDataParameter implementing object. This method is used to
            produce parameters for expression values. 
            </summary>
            <param name="name">name to be used for the parameter.</param>
            <param name="direction">Direction for the parameter</param>
            <param name="value">value the parameter is for.</param>
            <returns>Valid parameter for usage with the target database.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateLikeParameter(System.String,System.String)">
            <summary>
            Creates a valid Parameter for the pattern in a LIKE statement. This is a special case, because it shouldn't rely on the type of the
            field the LIKE statement is used with but should be the unicode varchar type. 
            </summary>
            <param name="fieldName">The name of the field the LIKE statement is used with.</param>
            <param name="pattern">The pattern to be passed as the value for the parameter. Is used to determine length of the parameter.</param>
            <returns>Valid parameter for usage with the target database.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateLikeParameter(System.String,System.String,System.Int32)">
            <summary>
            Creates a valid Parameter for the pattern in a LIKE statement. This is a special case, because it shouldn't rely on the type of the
            field the LIKE statement is used with but should be the unicode varchar type. 
            </summary>
            <param name="fieldName">The name of the field the LIKE statement is used with.</param>
            <param name="pattern">The pattern to be passed as the value for the parameter. Is used to determine length of the parameter.</param>
            <param name="targetFieldDbType">Type of the target field db</param>
            <returns>Valid parameter for usage with the target database.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateFieldName(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,System.String,System.String,System.Boolean,System.String,System.String)">
            <summary>
            Creats a valid field name based on the passed in IFieldPersistenceInfo implementation. The fieldname is
            ready to use in queries and contains all pre/postfix characters required.
            </summary>
            <param name="persistenceInfo">IFieldPersistenceInfo instance used to formulate the fieldname</param>
            <param name="fieldName">name of the entity field, to determine if an alias is required</param>
            <param name="objectAlias">Alias of object the field maps to. Only specified when called from a predicate.</param>
            <param name="appendAlias">When true, the routine should construct an alias construction statement.</param>
            <param name="containingObjectName">Name of the containing object which defined the field with name fieldName.</param>
            <param name="actualContainingObjectName">Name of the containing object which actually holds the field with the name fieldname.</param>
            <returns>
            Valid field name for usage with the target database.
            </returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateValidAlias(System.String)">
            <summary>
            Routine which creates a valid alias string for the raw alias passed in. For example, the alias will be surrounded by "[]" on sqlserver. 
            Used by the RelationCollection to produce a valid alias for joins.
            </summary>
            <param name="rawAlias">the raw alias to make valid</param>
            <returns>valid alias string to use.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateFieldName(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore,SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,System.String,System.String,System.Int32@,System.Boolean)">
            <summary>
            Creates the name for the field, and takes into account an aggregate function present and an expression present. If one or both are present, the
            field is replaced with (expression) or surrounded with (aggregate) the function (if applyAggregateFunction is true).
            </summary>
            <param name="fieldCore">fieldcore part of the field. Required to determine expression and aggregate function</param>
            <param name="persistenceInfo">persistence info object for the field.</param>
            <param name="fieldName">name for the field to be used</param>
            <param name="objectAlias">Alias for object hte field belongs to</param>
            <param name="uniqueMarker">uniquemarker variable for expression's toquerytext method.</param>
            <param name="applyAggregateFunction">flag to apply aggregate function or not. Aggregate functions can't be applied when the call originates
            from a predicate which is not part of a having clause.</param>
            <returns>string representing the field</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateFieldNameSimple(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,System.String,System.Boolean)">
            <summary>
            Creats a valid field name based on the passed in IFieldPersistenceInfo implementation. The fieldname is
            ready to use in queries and contains all pre/postfix characters required. The fieldname is 'simple' in that
            it doesn't contain any catalog, schema or table references. 
            </summary>
            <param name="persistenceInfo">IFieldPersistenceInfo instance used to formulate the fieldname</param>
            <param name="fieldName">name of the entity field, to determine if an alias is required</param>
            <param name="appendAlias">When true, the routine should construct an alias construction statement.</param>
            <returns>Valid field name for usage with the target database.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateObjectName(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo)">
            <summary>
            Creates a valid object name (f.e. a name for a table or view) based on the passed in IFieldPersistenceInfo implementation. The fieldname is
            ready to use in queries and contains all pre/postfix characters required. 
            </summary>
            <param name="persistenceInfo">IFieldPersistenceInfo instance which source object info is used to formulate the objectname</param>
            <returns>Valid object name</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.ConvertExpressionOperator(SD.LLBLGen.Pro.ORMSupportClasses.ExOp)">
            <summary>
            Converts the passed in expression operator (exop) to a string usable in a query 
            </summary>
            <param name="operatorToConvert">Expression operator to convert to a string</param>
            <returns>The string representation usable in a query of the operator passed in.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateSubQuery(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore[],SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo[],SD.LLBLGen.Pro.ORMSupportClasses.IPredicate,System.Int64,SD.LLBLGen.Pro.ORMSupportClasses.ISortExpression,SD.LLBLGen.Pro.ORMSupportClasses.IRelationCollection,SD.LLBLGen.Pro.ORMSupportClasses.IGroupByCollection,System.Boolean,System.Int32@)">
            <summary>
            Creates a new Select Query which is ready to use as a subquery, based on the specified select list and the specified set of relations.
            </summary>
            <param name="selectList">list of IEntityFieldCore objects to select</param>
            <param name="fieldPersistenceInfos">Array of IFieldPersistenceInfo objects to use to build the select query</param>
            <param name="selectFilter">A complete IPredicate implementing object which contains the filter for the rows to select. When set to null, no 
            filtering is done, and all rows are returned.</param>
            <param name="maxNumberOfItemsToReturn"> The maximum number of items to return with this retrieval query. 
            If the used Dynamic Query Engine supports it, 'TOP' is used to limit the amount of rows to return. 
            When set to 0, no limitations are specified.</param>
            <param name="sortClauses">The order by specifications for the sorting of the resultset. When not specified, no sorting is applied.</param>
            <param name="relationsToWalk">list of EntityRelation objects, which will be used to formulate a FROM clause with INNER JOINs.</param>
            <param name="groupByClause">the group by clause to use</param>
            <param name="allowDuplicates">If true, duplicates are allowed, otherwise DISTINCT (if applicable) is emitted.</param>
            <param name="uniqueMarker">a unique marker value to use. </param>
            <returns>IRetrievalQuery instance which is ready to be used.</returns>
            <exception cref="T:System.ArgumentNullException">When selectList is null or fieldsPersistenceInfo is null or relationsToWalk is null</exception>
            <exception cref="T:System.ArgumentException">When selectList contains no EntityFieldCore instances or fieldsPersistenceInfo is empty.</exception>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.ToUpperFunctionName">
            <summary>
            Returns the SQL functionname to make a string uppercase.
            </summary>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateHintStatement(SD.LLBLGen.Pro.ORMSupportClasses.RdbmsHint,System.String,System.Object[])">
            <summary>
            Creates the hint statement for the hint passed in.
            </summary>
            <param name="hint">Hint specification to create the statement for.</param>
            <param name="targetName">Name of the target the hint is for. This name is in full format, so on sqlserver this is [catalog].[schema].[table] and on
            other databases it can be for example "schema"."table".</param>
            <param name="values">Additional parameters for the hint statement producer. The values can be very provider specific.</param>
            <returns>the hint statement, ready to use.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateParameterName(System.String)">
            <summary>
            Creates from the passed in EntityField name a name usable for a Parameter. All spaces will be replaced by "_" characters. A "@" is added
            as a prefix. 
            </summary>
            <param name="fieldName">EntityField name to use as base for the parameter name.</param>
            <returns>Usable parameter name.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.StripObjectNameChars(System.String)">
            <summary>
            Strips the object name chars from the name passed in. For example [name] will become name
            </summary>
            <param name="toStrip">To strip.</param>
            <returns>
            name without the name's object name chars (Which are db specific)
            </returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.ConvertSqlDbTypeToDbType(System.Data.SqlDbType)">
            <summary>
            Converts the type of the SQL db type to db.
            </summary>
            <param name="toConvert">To convert.</param>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.CreateParameterInstance">
            <summary>
            Creates the parameter instance.
            </summary>
        </member>
        <member name="P:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificCreator.UseNoLockHintsForObjectNames">
            <summary>
            Gets / sets useNoLockHintsForObjectNames
            </summary>
        </member>
        <member name="T:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificExceptionInfoRetriever">
            <summary>
            Retriever class which retrieves the db specific information from the passed in sqlexception. This way the db specific info can be obtained in
            db generic code.
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerSpecificExceptionInfoRetriever.GetExceptionInfo(System.Exception)">
            <summary>
            Gets the exception info which is included in the passed in db specific exception. This retrieval has to be done in this class as not all .NET
            providers derive their exception classes from DbException.
            </summary>
            <param name="dbSpecificException">The db specific exception object.</param>
            <returns>
            A dictionary with per exception info element the value retrieved from the db specific exception
            </returns>
        </member>
        <member name="T:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator">
            <summary>
            Implements IDbSpecificCreator for SqlServer CE. 
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.#ctor">
            <summary>
            CTor
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.CreateParameter(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore,SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,System.Data.ParameterDirection,System.Object)">
            <summary>
            Creates a valid Parameter based on the passed in IEntityFieldCore implementation and the passed in IFieldPersistenceInfo instance
            </summary>
            <param name="field">IEntityFieldCore instance used to base the parameter on.</param>
            <param name="persistenceInfo">Persistence information to create the parameter.</param>
            <param name="direction">The direction for the parameter</param>
            <param name="valueToSet">Value to set the parameter to.</param>
            <returns>Valid parameter for usage with the target database.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.CreateLikeParameter(System.String,System.String,System.Int32)">
            <summary>
            Creates a valid Parameter for the pattern in a LIKE statement. This is a special case, because it shouldn't rely on the type of the
            field the LIKE statement is used with but should be the unicode varchar type.
            </summary>
            <param name="fieldName">The name of the field the LIKE statement is used with.</param>
            <param name="pattern">The pattern to be passed as the value for the parameter. Is used to determine length of the parameter.</param>
            <param name="targetFieldDbType">Type of the target field db</param>
            <returns>
            Valid parameter for usage with the target database.
            </returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.CreateValidAlias(System.String)">
            <summary>
            Routine which creates a valid alias string for the raw alias passed in. For example, the alias will be surrounded by "[]" on sqlserver. 
            Used by the RelationCollection to produce a valid alias for joins.
            </summary>
            <param name="rawAlias">the raw alias to make valid</param>
            <returns>valid alias string to use.</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.CreateFieldName(SD.LLBLGen.Pro.ORMSupportClasses.IEntityFieldCore,SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo,System.String,System.String,System.Int32@,System.Boolean)">
            <summary>
            Creates the name for the field, and takes into account an aggregate function present and an expression present. If one or both are present, the
            field is replaced with (expression) or surrounded with (aggregate) the function (if applyAggregateFunction is true).
            </summary>
            <param name="fieldCore">fieldcore part of the field. Required to determine expression and aggregate function</param>
            <param name="persistenceInfo">persistence info object for the field.</param>
            <param name="fieldName">name for the field to be used</param>
            <param name="objectAlias">Alias for object hte field belongs to</param>
            <param name="uniqueMarker">uniquemarker variable for expression's toquerytext method.</param>
            <param name="applyAggregateFunction">flag to apply aggregate function or not. Aggregate functions can't be applied when the call originates
            from a predicate which is not part of a having clause.</param>
            <returns>string representing the field</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.CreateObjectName(SD.LLBLGen.Pro.ORMSupportClasses.IFieldPersistenceInfo)">
            <summary>
            Creates a valid object name (f.e. a name for a table or view) based on the passed in IFieldPersistenceInfo implementation. The fieldname is
            ready to use in queries and contains all pre/postfix characters required. 
            </summary>
            <param name="persistenceInfo">IFieldPersistenceInfo instance which source object info is used to formulate the objectname</param>
            <returns>Valid object name</returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.ConvertSqlDbTypeToDbType(System.Data.SqlDbType)">
            <summary>
            Converts the type of the SQL db type to db.
            </summary>
            <param name="toConvert">To convert.</param>
            <returns></returns>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificCreator.ConvertToSqlCeCompatibleType(System.Data.SqlDbType,System.Int32)">
            <summary>
            Converts the passed in SqlServer type to the SqlCe compatible type. All non unicode types are converted to unicode types. Smallmoney is converted
            to money, varbinary with a size bigger than 8000 is converted to image, varchar and nvarchar fields with a size bigger than 8000 are converted to ntext.
            </summary>
            <param name="sqlServerType">SQL server type.</param>
            <param name="maxLength">Length of the max.</param>
            <returns></returns>
        </member>
        <member name="T:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificExceptionInfoRetriever">
            <summary>
            Retriever class which retrieves the db specific information from the passed in sqlexception. This way the db specific info can be obtained in
            db generic code.
            </summary>
        </member>
        <member name="M:SD.LLBLGen.Pro.DQE.SqlServer.SqlServerCeSpecificExceptionInfoRetriever.GetExceptionInfo(System.Exception)">
            <summary>
            Gets the exception info which is included in the passed in db specific exception. This retrieval has to be done in this class as not all .NET
            providers derive their exception classes from DbException.
            </summary>
            <param name="dbSpecificException">The db specific exception object.</param>
            <returns>
            A dictionary with per exception info element the value retrieved from the db specific exception
            </returns>
        </member>
    </members>
</doc>
